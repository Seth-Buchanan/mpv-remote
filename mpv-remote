#!/usr/bin/python3
import serial.tools.list_ports
import socket
import sys
import keyboard
from subprocess import call
from time import sleep

isWindows = sys.platform.startswith('win')

ports = serial.tools.list_ports.comports()
serialInst = serial.Serial()

portVar = "/dev/ttyACM0"

serialInst.baudrate = 9600
serialInst.port = portVar
serialInst.open()


def main():
    while True:
        mpvMode()
        # netrwMode()
# TODO: make "keyboard use" function
# TODO: make command dictionary
# TODO: make better file explorer vs mpv detection


def mpvMode():
    while True:
        if serialInst.in_waiting:
            packet = serialInst.readline().rstrip()
            # rstrip() removes the \r\n off the end of the arduino input

            print(packet)  # returns hex value that the script is comparing

            MPVCommands = {
                b'E7180586': b'cycle pause',       # enter
                b'BE410586': b'quit',              # .
                b'EA150586': b'seek 5',            # >
                b'E9160586': b'seek -5',           # <
                b'BD420586': b'seek 60',           # ^
                b'BC430586': b'seek -60',          # v
                b'807F0586': b'playlist-next',     # >>|
                b'7F800586': b'playlist-prev',     # |<<
                b'E31C0586': b'cycle sub',         # CCD
                b'E8170586': b'show-progress',     # INFO*
                b'F6090586': b'cycle fullscreen',  # 0
                b'F30C0586': b'add volume 2',      # vol ^
                b'F20D0586': b'add volume -2'      # vol v
            }

            for hex in MPVCommands:
                if packet == hex:
                    called_command = MPVCommands.get(hex)
                    doMpvCmd(called_command)
                else:
                    print("unbound button")

            sleep(.1)
            # netrwMode() # uncomment if you want to control from netrw
            # TODO: use mpv plugin to browse video files


def netrwMode():
    while True:
        if serialInst.in_waiting:
            packet = serialInst.readline().rsrip()
            # print(packet)

            if packet == b'E7180586':    # enter
                click("`")
                break

            elif packet == b'BE410586':  # .
                doMpvCmd(b'quit')
                break

            elif packet == b'EA150586':  # >
                click("enter")

            elif packet == b'E9160586':  # <
                click("-")

            elif packet == b'BD420586':  # ^
                click("k")

            elif packet == b'BC430586':  # v
                click("j")

            elif packet == b'F30C0586':  # vol ^
                call(["pactl", "set-sink-volume", "@DEFAULT_SINK@",  "+20%"])

            elif packet == b'F20D0586':  # vol v
                call(["pactl", "set-sink-volume", "@DEFAULT_SINK@",  "-20%"])
        sleep(.1)
    mpvMode()


def click(key):
    keyboard.press(key)
    sleep(.1)
    keyboard.release(key)

    # TODO: make windows compatible


def doMpvCmd(thecmd):
    thecmd.append("\n")
    # adds the new line character that effectively enters the command
    try:
        if isWindows:
            f = open(r'\\.\pipe\mpv-pipe', 'wb')
            f.write(thecmd)
            f.close()
        else:
            client = socket.socket(socket.AF_UNIX)
            client.connect('/tmp/mpv-socket')
            client.send(thecmd)
            client.close()
    except IOError:
        # keeping silent in case mpv is not open
        pass


main()

# portList = []
# for onePort in ports:
#     portList.append(str(onePort))
#
# val = input("select Port: COM")
#
# for i in range(0, len(portList)):
#     if portList[i].startswith("COM" + str(val)):
#         portVar = "COM" + str(val)
#         print(portVar[i])
